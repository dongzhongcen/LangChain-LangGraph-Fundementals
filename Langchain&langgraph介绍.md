# LangChain 与 LangGraph 介绍

## 一、AI 时代下的编程范式

### 1. Vibe Coding：氛围编程

#### 1.1 起源背景

近十年来，低代码/无代码平台与 AI 辅助编程工具持续渗透软件开发领域。如今，一种名为 **Vibe Coding（氛围编程）** 的新型实践迅速崛起，深刻挑战了人们对"程序员职责边界"的既有认知。

所谓 Vibe Coding，本质上是一种**以自然语言驱动代码生成**的 AI 辅助开发方式：开发者只需用口语化的描述向经过代码优化训练的大语言模型（LLM）阐明问题，由模型负责软件的实际生成，从而将开发者从底层代码的编写与调试中解放出来。

这一概念由 OpenAI 联合创始人、特斯拉前 AI 总监 Andrej Karpathy 于 2025 年 2 月首次提出，随即在技术社区迅速引爆。Vibe Coding 的支持者主张：哪怕是几乎零编程基础的业余人士，也能在这种模式下顺利开发出可运行的软件，代表了一种更直觉化、更低门槛的开发范式转变。

其核心特征在于：**使用者通常在尚未完全理解代码底层逻辑的前提下，直接接受并使用模型生成的结果。**

事实上，与仅将 LLM 当作辅助输入工具的做法不同，Vibe Coding 在形式上仍然需要开发者参与代码的审查、测试与理解。其真正的精髓，在于彻底沉浸于 AI 助手的"氛围"之中，将具体实现的工作全权委托给模型。正如 Karpathy 最初描述的那样：这与其说是编程，不如说是一种"看→说→跑→粘贴"的循环——而且大多数时候确实能用。

Vibe Coding 标志着软件开发模式的范式级迁移：**从精细的手工编码，转向更高层次的意图表达与 AI 引导**，人类开发者的角色由"代码执行者"转变为"需求导演"。

```
开发者 → 自然语言描述 → AI 模型 → 生成代码 → 开发者测试反馈 → [循环]
```

#### Vibe Coding 的三大优势

| 优势               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| **提升开发效率**   | 将繁琐的样板代码交给 AI，原本需要数日的原型开发可在数小时内完成 |
| **降低参与门槛**   | 用自然语言编程，非 CS 背景人员同样可以将想法转化为可运行软件 |
| **聚焦创意与设计** | 开发者得以将精力集中于产品构想和架构层面，而非实现细节       |

这一变革对开发者的能力要求产生了显著影响：

1. **问题定义与需求表达**能力变得更加核心——如何清晰、精准地用自然语言描述预期结果，已成为关键技能。
2. 开发者需要具备**指导和审查 AI 产出**的能力，更像是扮演"技术编辑"或"代码审查员"的角色。
3. **系统设计与架构理解**的重要性超越了底层编码本身，批判性思维与全局把控能力变得愈发不可或缺。
4. 学习与 AI 高效沟通的**提示技巧（Prompt Engineering）**，是在这一范式下保持竞争力的必要投入。

由此可见，开发者正经历一次身份重塑：从"代码生产者"向"能够驾驭 AI 工具的软件架构师或产品决策者"转型。

---

#### 1.2 Vibe Coding 的局限性

尽管 Vibe Coding 以其惊人的速度与极低的门槛带来了革命性的开发体验，但它并不足以全面取代传统的工程化开发方式。使用者往往会发现，AI 生成的代码普遍处于"能跑"而非"优秀"的水准。

其局限性主要体现在以下几个层面：

**① 代码质量与架构的"黑箱"困境**

AI 的核心目标是生成功能上可运行的代码，而非"优雅"或"可维护"的工程作品。模型对"什么是好架构"缺乏内在认知，无法主动考虑可扩展性与长期维护成本。

**② 上下文窗口与知识时效的双重制约**

- **"金鱼记忆"问题**：即便上下文长度持续扩展，LLM 仍难以完整理解一个大型项目的全貌。在迭代开发过程中，后期修改需求时，模型极易"遗忘"前期已确定的架构决策，进而生成与现有代码相冲突或重复的内容，导致系统逐渐腐化。
- **知识截止与"幻觉"**：模型训练数据存在时间截止点，对最新技术特性或库版本可能一无所知。更危险的是，它可能自信地"幻觉"出不存在的 API 或参数，生成看似正确实则无法运行的代码，这对开发者的甄别能力提出了很高要求。

**③ 安全性与可靠性的"隐形地雷"**

这是 Vibe Coding 在企业级应用中最致命的短板。

- **安全漏洞的无声植入**：AI 没有"安全意识"，可能轻易生成含有 SQL 注入、XSS 攻击、硬编码密钥或权限配置缺陷的代码。对金融、医疗等安全敏感系统而言，这是不可接受的风险。
- **可靠性缺乏保障**：生成的代码通常缺乏严格测试的支撑，在小规模场景下表现尚可，但在高并发、大数据量或边界条件下可能表现不稳定甚至崩溃。日志、监控与熔断机制的缺失，使线上问题排查极为困难。

**Vibe Coding 的正确定位：**

- ❌ **不适合**：架构设计、技术方案制定、代码质量保障、系统安全建设——这些核心战略性工作必须由具备扎实工程功底和深刻判断力的开发者主导。
- ✅ **适合**：生成样板代码、完成重复性任务、编写单元测试、解释复杂代码、提供灵感参考——这些"接地气"的工程活正是 AI 大展身手的地方。

目前真正运行在生产环境的代码，依然是工程师一行一行敲出来的。而改函数签名、重命名变量、写个小 Demo 或工具脚本，才是 AI 最适合的用武之地。

因此，Karpathy 本人后来也修正了立场，指出：**"更可行的做法是建立一套结构，让不同工具在不同场景各司其职，像接力赛一样协同完成开发任务。"**

---

### 2. AI 开发框架：新战略高地

当前，我们正处于人工智能变革的核心节点。大语言模型（LLM）的兴起不仅重塑了人机交互的方式，更从根本上改变了软件开发的底层逻辑。构建一个 AI 应用，早已不是简单地调用一个 API，而是需要系统性地应对数据处理、模型交互、任务编排与状态管理等一系列复杂挑战。

即便 AI 代码生成工具（Vibe Coding）的能力日益增强，其输出结果往往只达到"能用"的水平，距"优秀"仍有差距。真正的专业工程师，需要对架构设计、系统权衡与工程最佳实践有深刻理解——这正是学习框架的核心价值所在。

#### 2.1 框架的共同原则

AI 开发框架与传统框架（如 Java 生态中的 Spring、C++ 的 libcurl）在设计思想上高度一致，共享以下核心原则：

**抽象与封装**

| 框架      | 封装对象                                                     |
| --------- | ------------------------------------------------------------ |
| Spring    | Java EE 开发的复杂性（依赖注入、事务管理、MVC）              |
| libcurl   | 底层网络协议（HTTP、FTP、SMTP 等）的 socket 细节             |
| LangChain | 不同 LLM 供应商（OpenAI、Anthropic 等）、向量数据库（Chroma、Pinecone）及 Tools 的交互复杂性 |

**模块化与可组装性**

- **Spring**：通过依赖注入（DI）与控制反转（IoC）容器，将应用组织为高度可插拔的 Bean，支持灵活替换实现层。
- **LangChain**：核心思想是"链"（Chain），将 LLM、Prompts、Tools、Memory、Output Parsers 等模块像乐高积木一样自由组合，构建复杂的 AI 工作流。

#### 2.2 AI 框架的战略价值

以 LangChain、LangGraph 为代表的 AI 开发框架，正成为开发者在 AI 时代的"超级武器"。它们如同智能时代的操作系统，架起强大 AI 模型与复杂现实应用之间的桥梁。

掌握 AI 框架，能为开发者带来以下核心能力：

- **架构**：了解代码应以何种结构组织，形成清晰的系统蓝图。
- **质量**：具备判断 AI 生成代码是否合格的能力与标准。
- **安全**：框架内置的最佳实践与经验模式，能主动规避大量基础性风险。
- **集成**：高效地将 AI 生成的"零件"嵌入到经过验证的可靠大系统中。

学习这些框架不只是习得新技术，更是一项关键的战略投资，具体价值体现在：

- **提升效率，加速原型**：标准化的流程与预构建模块大幅减少重复编码工作，从概念到产品的迭代速度显著加快。
- **化繁为简，直击痛点**：以 LangChain 为例，它将复杂的 LLM 应用开发拆解为若干可管理的核心模块，专门针对开发中的高频痛点提供解决方案。
- **强大生态集成**：优秀框架（如 LangChain）已深度集成数百种主流工具与服务，涵盖各类 AI 模型与数据库，让开发者可以像搭积木一样自由组合技术栈。
- **思维升级**：帮助开发者建立从数据采集到服务部署的全链路系统性思维。
- **职业领先**：在 AI 时代，掌握主流开发框架已成为工程师的核心竞争力之一。

---

### 3. 未来展望

对于开发者而言，Vibe Coding 并不会全面取代传统编程技能，而是形成互补共生的新格局。可以预见的趋势是：开发者将越来越聚焦于高层次的系统设计、架构决策与核心业务逻辑，而将更多实现细节委托给 AI 完成。

未来的主流开发模式很可能是**混合式**的：借助 Vibe Coding 的速度优势处理前端界面与重复性工作，同时依托扎实的框架知识构建核心业务逻辑，保障系统架构的健壮性与安全性。

因此，学习 LangChain、LangGraph 这类框架，其战略价值在 Vibe Coding 时代不降反升，是在 AI 浪潮中驾驭更复杂项目、保持竞争优势的必备技能。

> **核心论断：「框架思维」驾驭「Vibe 工具」，才是未来开发者最强的核心竞争力。**

---

## 二、LangChain：LLM 应用开发的核心框架

### 1. LLM 驱动应用的主流框架生态

以 LLM 为核心驱动的应用框架，目标是为开发者提供构建复杂 AI 应用所需的完整工具集，涵盖带记忆的代理、复杂的 RAG 系统与多步骤工作流等场景。

以下按语言生态整理主流框架：

#### 1.1 Python 生态（绝对主流）

| 框架           | 核心特点与优势                                               | 典型适用场景                                                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **LangChain**  | 生态最成熟，灵活性极高。提供链、代理、检索器等全面组件，社区活跃，集成工具众多（涵盖大量向量数据库与模型供应商） | 几乎所有复杂 LLM 应用，尤其是需要高度定制化与多方工具集成的项目——大多数场景的首选 |
| **LlamaIndex** | 专注 RAG 与数据连接，在文档索引、查询与检索方面性能卓越，从基础到高级的检索策略一应俱全，现已扩展为全功能框架 | 以私有数据查询与分析为核心的应用，如企业知识库、文档智能问答、数据增强型聊天机器人 |

#### 1.2 JavaScript / TypeScript 生态（前端与全栈）

| 框架              | 核心特点与优势                                               | 典型适用场景                                                 |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **LangChain.js**  | Python 版 LangChain 的官方 JS/TS 移植，API 设计高度对齐，支持链、代理、工具等核心功能 | 全栈开发、浏览器扩展、Edge Runtime（如 Vercel Edge Functions）、Next.js 等现代 Web 框架集成 |
| **LlamaIndex.TS** | LlamaIndex 的 TypeScript 版本，专注于 TS 生态中的 RAG 应用   | 在 Next.js、Nuxt 等全栈框架中构建强大的 RAG 应用             |

#### 1.3 Java 生态

| 框架                  | 核心特点与优势                                               | 典型适用场景                                                 |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **LangChain4j**       | 受 LangChain 启发、专为 JVM 设计的框架，API 风格符合 Java 开发习惯（注：非 LangChain 官方出品，属社区项目） | 将 LLM 能力集成到现有 Java 企业应用中，如微服务或大型后端系统 |
| **Spring AI**         | Spring 官方项目，与 Spring 生态无缝整合，提供统一 API 与数据抽象，生产就绪特性完善 | 所有基于 Spring Boot 的项目，尤其是追求稳定性与框架原生集成的企业级生产系统 |
| **Spring AI Alibaba** | Spring AI 的扩展项目，由阿里云官方支持，深度集成灵积模型平台及通义千问等模型，提供开箱即用的配置 | 深度依赖阿里云生态的 Spring 项目；需低延迟调用通义千问系列模型或与 OSS、NAS 等云服务联动的场景 |

#### 1.4 C++ 生态

C++ 生态在 LLM 应用全栈框架领域相对缺席，这背后有深刻的技术与生态原因。

**① 开发效率与快速迭代的需求不匹配**

LLM 应用开发目前仍处于高度实验性、快速迭代的阶段：

- **Python/JS**：作为动态语言，天然具备快速原型设计的优势，开发者可以即时调整提示词、修改工作流逻辑并立刻看到效果，这种快速反馈循环对探索模型能力至关重要。
- **C++**：编译型语言虽性能卓越，但编译与测试周期较长，这种"厚重"的开发体验与 LLM 应用所需的"敏捷"开发模式存在根本性的错位。

**② 生态重心不同**

LLM 应用严重依赖丰富的第三方库：

- Python 拥有无与伦比的库支持：机器学习框架（PyTorch、TensorFlow）、数据处理（NumPy、Pandas）、Web 集成（FastAPI）、主要模型供应商的官方 SDK（OpenAI、Anthropic 等首选 Python）。
- C++ 的传统优势在于系统编程、游戏开发、高频交易与嵌入式领域，对现代 Web API 和云服务集成的库支持远不如 Python 丰富。

**③ 技术架构的天然分工（核心原因）**

现代 LLM 应用架构普遍遵循**"Python/Java 负责应用层（做什么），C++ 负责底层推理（怎么做）"**的分工模式。

典型案例：**`llama.cpp`**（官网：https://github.com/ggerganov/llama.cpp）

```
架构分工示意：

上层应用（Python/Java） ──API 调用──→ llama.cpp HTTP 服务
                                            ↓
                                    C++ 高效推理引擎
                                    （量化 + 低内存占用）
```

llama.cpp 以 C/C++ 编写，专注高效推理 LLaMA 系列及其他架构模型，以出色的性能和极低的内存占用（通过量化）著称。它内置 HTTP API 服务能力，让上层 Python 或 JavaScript 应用通过 API 调用的方式使用它，从而将 C++ 的推理性能与 Python 的应用开发效率完美结合。

> 虽然 C++ 缺席了"全栈 AI 框架"的舞台，但它是整个 LLM 技术栈中不可或缺的基石——llama.cpp 就是最成功的证明，使得在消费级硬件上本地运行大模型成为可能。

#### 1.5 如何选择框架？

框架选择的核心决策逻辑：

**团队技术栈优先：**
- 团队主力是 Java → **LangChain4j** 或 **Spring AI**
- 需要极致性能、离线部署或资源受限场景（手机、嵌入式）→ **llama.cpp**（C++）
- 常见的混合架构：C++ 实现高性能推理引擎 + Java/Python 构建业务层与 API 接口

**项目需求导向：**
- 研究性质或需要最大灵活性 → **Python（LangChain）**
- 以 RAG 为核心 → **LlamaIndex（Python/TS）**
- 深度集成现有企业级后端（Spring 应用）→ **Spring AI**
- 面向 Web 的全栈应用或边缘函数 → **LangChain.js**

**社区与支持：**
Python 和 JS 生态的框架（LangChain）迭代最快、社区最活跃，遇到问题时更容易获取解决方案，是大多数人的默认选择。

---

### 2. LangChain 详解

#### 2.1 将 LLM 嵌入复杂应用时遇到的典型问题

使用过原生大模型的开发者往往会发现：尽管 LLM 在某些场景（如搜索增强问答）中表现令人振奋，但一旦试图将其真正嵌入应用程序，便会遭遇一系列棘手问题：

- 简单提示词得到的回答经常出现"幻觉"（凭空捏造信息）？
- 提示词的结构能否统一规范，便于团队协作与维护？
- 如何在开发中实现不同模型的低成本切换？
- 模型输出是非结构化文本，如何与需要结构化数据的程序接口对接？
- 如何突破预训练模型的知识时效限制，引入实时数据？
- 如何让模型连接外部工具或系统，执行具体的现实任务？

**以"智能医疗咨询助手"为例，逐一剖析这些问题：**

假设我们要开发一个可接受用户症状描述的医疗咨询助手，它需要提供初步疾病分析、日常护理建议，并判断是否需要立即就医。

---

**场景一：幻觉问题**

用户问："我三岁的孩子吞下了一枚纽扣电池，该怎么办？"

```
问题输入 → LLM → 错误输出：
"首先不要惊慌，可以让孩子多喝水或吃些香蕉、面包等食物，
试图将电池包裹并自然排出体外..."
```

> ⚠️ **该建议完全错误且可能致命。** 纽扣电池卡在食道后会快速泄漏腐蚀性物质，灼伤内脏，必须立即送医。这是典型的"幻觉"输出——模型基于训练数据泛化生成了错误答案。

---

**场景二：提示词不规范**

开发团队 A 工程师写：`你是一个医生，请回答以下医学问题：[用户问题]`

开发团队 B 工程师写：`## 指令 ## 基于最新医学知识，用通俗语言解释以下症状。## 症状 ## [用户输入] ## 限制 ## 不要给出确定的诊断。`

> 提示词的质量与风格直接决定输出的准确性和安全性。没有统一规范，会导致应用行为不可预测、难以调试，且无法规模化地优化效果。

---

**场景三：模型切换成本极高**

项目初期用 GPT-3.5 Turbo 快速原型，后期希望切换到更强大的 GPT-5 或开源模型 Llama 3：

```
GPT-3.5 Turbo           切换？        GPT-5
（已完成 OpenAI 接入）   ────→    （提示词行为可能不同）

                         切换？        Llama 3
                         ────→    （API 接口完全不同，
                                   参数名称各异）
```

> 一旦选定模型，整个代码库就与该模型的 API 强耦合。切换模型几乎等于重写所有与 LLM 交互的逻辑，严重制约了技术选型的灵活性。

---

**场景四：非结构化输出难以程序化处理**

应用需要将"可能疾病"的分析结果结构化展示在前端列表中：

```
实际输出（自然语言）：
"根据您的症状，您可能患有流行性感冒（可能性较高）
或普通感冒（可能性中等）。建议您多休息、多喝水..."

期望输出（结构化 JSON）：
{
  "possible_conditions": [
    {"name": "流行性感冒", "confidence": "high"},
    {"name": "普通感冒", "confidence": "medium"}
  ],
  "advice": "多休息，多喝水...",
  "urgency": "consult_within_24_hours"
}
```

> 程序无法直接从自然语言中可靠地提取结构化字段，必须编写复杂且脆弱的正则表达式，或再调用一个模型来解析上一个模型的输出，极大增加了系统复杂度。

---

**场景五：知识时效性问题**

用户问："针对奥密克戎 XBB.1.5 变种，最新的加强针效果如何？"

> 主流 LLM 的训练数据均有截止日期，对截止日期之后的最新医学研究一无所知，要么拒绝回答，要么基于过时信息给出错误答案——而医疗信息的时效性至关重要。

---

**场景六：需要连接外部工具**

用户问："布洛芬和阿司匹林可以同时吃吗？"

```
实际情况：          用户问题 → LLM → 直接生成答案（可能不准确）

理想流程：
用户问题 → LLM 识别意图 → 调用药物相互作用 API
                            ↓
                         返回专业数据库结果
                            ↓
                    LLM 将结构化数据翻译为用户语言 → 输出答案
```

> 让 LLM 可靠地决定"何时调用哪个工具、如何解析返回结果"，是一个极其复杂的系统工程问题。

**问题汇总与对应解决方向：**

| 问题               | 解决方向                                     |
| ------------------ | -------------------------------------------- |
| 幻觉、提示词不规范 | 提示词工程 + 检索增强生成（RAG）             |
| 模型切换成本高     | LLM API 抽象层（LangChain 统一接口）         |
| 非结构化输出       | 输出解析（Output Parsers），强制 JSON Schema |
| 知识陈旧           | RAG 注入实时外部知识                         |
| 无法连接外部工具   | 智能体（Agent）框架，LLM 作为任务规划大脑    |

一个成熟的"智能医疗咨询助手"，最终不会是对原生大模型的直接调用，而是由精心设计的提示词模板、RAG 检索系统、外部工具 API 调用与输出解析器共同组成的复杂系统——原生 LLM 只是这个系统的核心引擎之一，而非全部。

---

#### 2.2 LangChain：为上述痛点而生

**LangChain 能够系统性地解决上述所有问题。**

LangChain 是一个专为构建 LLM 驱动应用而设计的开发框架。其核心思路是：**将自然语言处理（NLP）流程拆解为标准化的可组合组件**，让开发者能够自由搭配、高效定制工作流。

- **组件（Components）**：提供构建 AI 应用所需的一系列核心积木，包括语言模型接口、输出解析器、检索器等。
- **NLP 流程**：完成一个特定 AI 任务所需的一系列有序步骤。例如，"基于公司文档构建问答机器人"的典型流程包括：读取文档 → 切割文本 → 向量化（嵌入）→ 存储向量 → 接收用户提问 → 检索相关段落 → 组合提示词发送给 LLM → 解析输出并返回答案。

```
Document Loading → Splitting → Storage（Vectorstore）
      ↓                                    ↓
    URLs/PDFs                         Retrieval（相关片段）
    Database                               ↓
                                    Prompt + LLM → Answer
                                    ↑
                                Query（用户问题）
```

#### 2.3 LangChain 的核心技术特点

LangChain 的设计精髓在于**以链式（Chain）方式整合多个组件**，从而构建功能完备的 LLM 应用。

"链式"的核心价值：LangChain 允许将多个步骤或组件串联起来，无需各自独立触发，而是一次性执行整条"链"上的所有流程。

**示例：借助提示词完成一次 LLM 问答**

不使用 Chain 时，需要分别执行：
1. 提示词模板组件（模板实例化）
2. 大模型组件（输入并生成输出）

使用 Chain 时，只需执行一次：

```
用户输入："我感到心烦、恶心一周了。xxxxxx"
         ↓（1. 输入到 Chain）
提示词模板组件：你是一个医生，请回答以下医学问题：${query}
         ↓（1. 模板实例化）
完整 Prompt："你是一个医生，请回答以下医学问题：
              我感到心烦、恶心一周了。xxxxxx"
         ↓（2. 输入到大模型组件）
         LLM
         ↓（3. 输出）
         结果
```

LangChain 提供的主要标准化模块：

| 模块                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **统一的模型调用**           | 抽象化接口支持 OpenAI GPT、Anthropic Claude 等多种模型，开发者可灵活切换供应商 |
| **灵活的提示词管理**         | 提供 Prompt Templates，支持动态生成输入内容，管理少样本示例与提示选择策略 |
| **可组合的任务链（Chains）** | 将多步骤串联为完整工作流，支持自定义链实现复杂任务编排       |
| **上下文记忆（Memory）**     | 存储多轮对话状态（注：当前此功能已由 LangGraph 接管，原有实现已过时） |
| **检索与向量存储集成**       | 支持文档加载、切割、向量化、存储到向量数据库，查询时检索相关信息注入 LLM，简化 RAG 应用开发，兼容 FAISS、Pinecone、Chroma 等主流向量数据库 |

LangChain 还在框架之外构建了完整的生态体系：
- **LangSmith**：用于 LLM 应用的调试、监控与评估的可观测性平台
- **LangGraph Platform**：用于复杂代理应用的部署与运维

---

### 3. LangChain 的起源与发展历程

| 时间节点    | 里程碑事件                                                   |
| ----------- | ------------------------------------------------------------ |
| 2022.10     | Harrison Chase 开源发布 LangChain，旨在解决 LLM（如 GPT-3）嵌入应用的核心痛点 |
| 2023        | 成立 LangChain 公司，获数千万美元融资，估值达 2 亿美元；推出 JS/TS 支持，拓展前端与全栈开发者生态；持续扩展对 Anthropic、HuggingFace、Llama 等模型的支持 |
| 2024.01     | 发布 **0.1.0 首个稳定版**：引入 `langchain-core`（稳定抽象接口），将第三方集成解耦至 `langchain-community` 或独立伙伴包；推出 **LCEL（LangChain 表达式语言）**，支持高度定制化的链执行流程 |
| 2024.05     | 发布 **0.2.0**：强化异步调用与流式输出，优化向量数据库与检索系统集成 |
| 2024 下半年 | 发布 **0.3.x**：持续增加集成（向量存储、工具插件等）并改进性能 |
| 2025.09     | 发布 **1.x Alpha 内测版**：统一各供应商间的现代 LLM 功能（推理、引用、服务器端工具调用等），新增预构建 LangGraph 链和代理，框架聚焦核心抽象，新增 `langchain-legacy` 向后兼容包 |

> 版本发布记录：https://github.com/langchain-ai/langchain/releases

---

## 三、LangGraph：面向复杂工作流的图式架构

### 1. LangGraph 介绍

#### 1.1 LangChain 链式结构的局限性

LangGraph 诞生于 LangChain 生态系统中，其出现与 AI 代理应用日益增长的复杂性密切相关。当开发者尝试构建更高级的 AI 代理与多轮对话系统时，传统链式结构的天花板开始显现：

- 链式流程本质上是**线性且预先定义**的执行路径，难以有效应对需要循环、分支或长期状态维护的复杂场景。
- 构建多智能体协作、支持人工介入（Human-in-the-loop）或长时间持续运行的任务时，需要更灵活的工作流管理与状态持久化机制。

**以"AI 客服工单处理代理"为例，剖析链式结构的具体限制：**

假设我们要构建一个能自动处理退货、产品咨询、投诉等客服工单的 AI 代理，理想的处理流程如下：

```
开始
 ↓
分类（判断用户意图：退货/咨询/投诉）
 ↓
信息收集（根据意图询问所需信息：如退货需订单号，咨询需产品型号）
 ↓ ←──────────────────────────────┐
处理与验证（查询数据库、调用 API）  │ 信息不完整时循环回收集
 ├── 需要人工 →  人工介入（转交人工客服）
 ↓  正常流程
总结与关闭（生成总结并关闭工单）
 ↓
结束
```

若用传统 `Chain A → Chain B → Chain C` 的线性结构构建，将遭遇以下四大具体问题：

**问题一：无法处理循环与动态路由**

在"信息收集"阶段，用户第一次可能提交了不完整的订单号。链式流程是单向的，无法自动"回跳"重新请求用户补充——只能让整条链失败，或输出一条僵硬的错误消息。"信息不完整则持续追问直至完整"这类循环逻辑，链式结构无法优雅地实现。

**问题二：状态维护困难**

客服对话通常是多轮的，持续时长从几分钟到几天不等。传统链在每次调用时都是"无状态"的，状态管理的全部压力落到开发者身上，需要依赖外部数据库手动存取对话上下文，代码逻辑将变得极为臃肿脆弱。

**问题三：难以优雅地融入人工介入**

当 AI 无法处理时，需要无缝转交人工客服。在链式结构中，这意味着流程在此中断。想要实现"暂停 AI 流程 → 等待人工处理 → 将结果返回 → 继续后续自动化步骤"的完整闭环，链式结构无能为力，整个工作流会断裂成互相割裂的两半。

**问题四：条件分支逻辑僵化**

不同用户意图需要截然不同的处理子流程：

- 投诉 → 走 A→B→C 路径
- 产品咨询 → 走 A→D→E 路径

在链式结构中实现这种条件分支极为笨拙，通常需要一个包含大量 if-else 逻辑的"主链"。工作流的核心逻辑被淹没在代码控制流语句中，难以可视化、调试与维护。

---

#### 1.2 LangGraph：图式架构解决方案

为系统性地解决上述问题，LangChain 团队于 2024 年推出了 **LangGraph 框架**，以**图结构（Graph）**与**状态化（Stateful）**的方式为复杂 AI 代理应用提供了全新的构建范式。

LangChain 团队将 LangGraph 定位为"**低层次的编排框架**"，专注于构建可控、可靠的 AI 代理工作流。目前，LinkedIn、Uber、GitLab 等公司据报道已将 LangGraph 用于生产环境中的复杂生成式 AI 代理系统。

将上述客服场景改用图结构表达：

```
             ┌─────────────────────────────────────────────────────┐
             │              Graph State（图状态）                   │
             │  intent         : 用户意图（return/inquiry/complaint）│
             │  collected_info : 已收集信息字典（订单号、问题描述等） │
             │  needs_human    : 是否需要人工介入（Boolean）          │
             │  is_verified    : 信息是否已验证（Boolean）            │
             │  is_complete    : 流程是否完成（Boolean）              │
             │  message_history: 对话历史列表（多轮交互支持）          │
             └─────────────────────────────────────────────────────┘

开始 → [分类节点] → [信息收集节点] ←──── 循环边（信息不完整时）
                          ↓
                    [处理与验证节点]
                    ├─条件边（needs_human=True）→ [人工介入节点]
                    └─条件边（正常流程）→ [总结关闭节点] → 结束
```

**LangGraph 与 LangChain 的关系：**

LangGraph 并非 LangChain 的替代品，而是其**扩展与补充**。LangGraph 底层大量复用 LangChain 的组件（模型接口、工具、记忆等），开发者可以在 LangGraph 的节点中直接调用 LangChain 的链或代理作为子流程。

两者分工明确：
- **简单线性任务** → LangChain 的链式结构已足够高效
- **复杂控制流、长期状态、多智能体协作** → LangGraph 提供更强大的支持

---

#### 1.3 LangGraph 的核心技术特点

LangGraph 将应用逻辑建模为**图（Graph）**结构：

- **节点（Node）**：代表一个具体的操作或处理步骤
- **边（Edge）**：代表节点间的数据流转与执行路径

```
                         普通边：Action 完成后总是让 LLM 决定下一步
                              ↑
入口边(entry) → [推理节点: LLM Agent] → 条件边（需要 Action?）
                      ↑                        ├─ Yes → [行动节点: Action] → 调用 Tools
                    调用LLM                     └─ No  → END

状态属性示例：
{
  input           : 输入信息
  chat_history    : 对话历史
  agent_outcome   : 推理节点输出类型（用于条件边判断）
  intermediate_steps: 中间行动步骤记录
}
```

相比链式结构，图式架构的核心优势：

| 特性               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| **循环与分支**     | 节点可以连接到任意其他节点（包括自身），轻松实现"信息不完整则持续追问"等循环逻辑 |
| **动态路由**       | 通过条件边，根据当前状态动态决定下一个执行节点，如根据分类结果路由到不同的处理子图 |
| **状态维护**       | 核心状态对象在整个图执行过程中自动持久化与传递，每个节点均可读写，天然支持长时间运行的任务 |
| **持久执行**       | 构建能经受故障、长时间运行的代理，自动从上次中断处恢复       |
| **人机协作**       | 在执行的任意时刻检查并修改代理状态，无缝融入人工监督环节     |
| **全面记忆**       | 兼具用于持续推理的短期工作记忆和跨会话的长期持久记忆         |
| **LangSmith 调试** | 借助可视化工具追踪执行路径、捕获状态转换、提供详细运行时指标 |
| **生产级部署**     | 专为有状态、长时间运行工作流设计的可扩展基础设施             |

**核心总结：** 用传统链式结构构建复杂 AI 代理，最终会演变为僵硬、脆弱、难以维护的"面条代码"；而 LangGraph 则能将其建模为灵活、可靠、可视化程度高、支持复杂逻辑（循环、分支、人工介入）的工作流图。

---

### 2. LangGraph 的起源与发展历程

| 时间节点    | 里程碑事件                                                   |
| ----------- | ------------------------------------------------------------ |
| 2024 初     | 作为实验性功能随 LangChain 0.1.0 版本一同发布，标志着从链式架构向图式架构的正式扩展 |
| 2024 中     | 开始独立演进，建立专属文档与代码仓库；引入 **Checkpoint（检查点）机制**，支持执行状态的定期保存，实现故障恢复与审计 |
| 2024 下半年 | 发布 0.2.x、0.3.x 等多个版本，增强异步执行与并发支持，提供更完善的类型定义与错误处理 |
| 2025        | 发布 0.4.x、0.5.x 等版本，形成完善的 Python 和 JavaScript 双语言实现；推出 **LangGraph Platform** 配套产品，简化复杂代理应用的部署与管理 |
| 2025.06     | 发布 0.6 版本，启动 **LangGraph v1.0 路线图计划**，面向社区收集功能需求以确定正式版特性 |

> 版本发布记录：https://github.com/langchain-ai/langgraph/releases



### 学习 AI 框架的价值维度

**技术实现价值**

AI 开发框架通过提供标准化的工具库与抽象机制，显著降低了开发、部署和运维 AI 应用的复杂度，让开发者得以将更多精力聚焦于业务逻辑与产品创新。

**个人成长价值**

| 价值维度             | 具体收益                                                     |
| -------------------- | ------------------------------------------------------------ |
| **吸收行业最佳实践** | 框架凝聚了领域专家的设计智慧与成熟方法，帮助开发者快速建立构建可靠 AI 系统的经验范式 |
| **培养系统架构思维** | AI 应用开发涵盖数据处理、模型调优、API 设计等多个维度，理解框架有助于形成全链路认知，提升系统级设计与把控能力 |
| **增强职业竞争力**   | 熟练掌握主流 AI 开发框架已成为 AI 工程师的关键硬实力，不仅拓宽职业可能性，更有助于在技术迭代中把握先机，抢占更具前景的发展位置 |

---

> **最终结论：** 那些能够有效驾驭 AI 工具的开发者，将取代那些不能的。新工具不会消除对专业人才的需求，只会重新定义对他们的能力要求——而框架知识，正是这种新能力的核心组成。